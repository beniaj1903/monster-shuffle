use rand::rngs::StdRng;
use rand::Rng;
use crate::models::{FieldPosition, MoveData, PokemonInstance};
use crate::game::{BattleState, PlayerTeam};
use super::super::redirection_system::apply_redirection;

/// Resuelve los objetivos de un movimiento basándose en el tipo de objetivo y la posición del usuario
///
/// Esta función determina a quién golpea un movimiento en combates dobles (VGC).
/// Retorna un vector de posiciones en el campo que serán afectadas por el movimiento.
///
/// # Parámetros
/// - `user_pos`: La posición del Pokémon que usa el movimiento
/// - `move_target_type`: El tipo de objetivo del movimiento (ej: "selected-pokemon", "all-opponents")
/// - `selected_target`: El objetivo seleccionado por el usuario (si aplica)
/// - `battle_state`: El estado de batalla para verificar qué posiciones están ocupadas por Pokémon vivos
/// - `player_team`: El equipo del jugador para verificar qué Pokémon están vivos
/// - `attacker`: El Pokémon que usa el movimiento (para redirection)
/// - `move_data`: Los datos del movimiento (para redirection)
/// - `rng`: Generador de números aleatorios para objetivos aleatorios
///
/// # Retorna
/// Un vector de posiciones en el campo que serán afectadas por el movimiento
pub fn resolve_targets(
    user_pos: FieldPosition,
    move_target_type: &str,
    selected_target: Option<FieldPosition>,
    battle_state: &BattleState,
    player_team: &PlayerTeam,
    attacker: &PokemonInstance,
    move_data: &MoveData,
    rng: &mut StdRng,
) -> Vec<FieldPosition> {
    eprintln!("[DEBUG] resolve_targets: user_pos={:?}, move_target_type={}, selected_target={:?}, battle_format={:?}", 
        user_pos, move_target_type, selected_target, battle_state.format);
    
    match move_target_type {
        // PRIORIDAD ABSOLUTA: El usuario mismo (ej: Swords Dance, Calm Mind)
        // IGNORA completamente selected_target del frontend
        "user" => {
            eprintln!("[DEBUG] resolve_targets: target='user' - Ignorando selected_target, retornando user_pos: {:?}", user_pos);
            vec![user_pos]
        }
        
        // PRIORIDAD ABSOLUTA: Un oponente aleatorio (ej: Outrage, Thrash, Petal Dance)
        // IGNORA selected_target, selecciona aleatoriamente
        "random-opponent" => {
            eprintln!("[DEBUG] resolve_targets: target='random-opponent' - Ignorando selected_target, seleccionando aleatoriamente");
            let mut available_opponents = Vec::new();
            if is_position_alive(FieldPosition::OpponentLeft, battle_state, player_team) {
                available_opponents.push(FieldPosition::OpponentLeft);
            }
            if is_position_alive(FieldPosition::OpponentRight, battle_state, player_team) {
                available_opponents.push(FieldPosition::OpponentRight);
            }
            
            if available_opponents.is_empty() {
                eprintln!("[DEBUG] resolve_targets: No hay oponentes vivos disponibles");
                vec![]
            } else {
                // Seleccionar un oponente aleatorio
                let index = rng.gen_range(0..available_opponents.len());
                let selected = available_opponents[index];
                eprintln!("[DEBUG] resolve_targets: Oponente aleatorio seleccionado: {:?}", selected);
                vec![selected]
            }
        }
        
        // Todos los oponentes (ej: Rock Slide, Surf)
        // IGNORA selected_target
        "all-opponents" => {
            eprintln!("[DEBUG] resolve_targets: target='all-opponents' - Ignorando selected_target");
            let mut targets = Vec::new();
            // Agregar posiciones de oponentes que estén vivas
            if is_position_alive(FieldPosition::OpponentLeft, battle_state, player_team) {
                targets.push(FieldPosition::OpponentLeft);
            }
            if is_position_alive(FieldPosition::OpponentRight, battle_state, player_team) {
                targets.push(FieldPosition::OpponentRight);
            }
            eprintln!("[DEBUG] resolve_targets: Objetivos 'all-opponents': {:?}", targets);
            targets
        }
        
        // Todos los otros Pokémon (ej: Earthquake, Explosion)
        // IGNORA selected_target
        "all-other-pokemon" => {
            eprintln!("[DEBUG] resolve_targets: target='all-other-pokemon' - Ignorando selected_target");
            let mut targets = Vec::new();
            // Agregar todos los oponentes
            if is_position_alive(FieldPosition::OpponentLeft, battle_state, player_team) {
                targets.push(FieldPosition::OpponentLeft);
            }
            if is_position_alive(FieldPosition::OpponentRight, battle_state, player_team) {
                targets.push(FieldPosition::OpponentRight);
            }
            // Agregar el aliado del usuario (si existe y está vivo)
            if let Some(ally_pos) = get_ally_position(user_pos) {
                if is_position_alive(ally_pos, battle_state, player_team) {
                    targets.push(ally_pos);
                }
            }
            eprintln!("[DEBUG] resolve_targets: Objetivos 'all-other-pokemon': {:?}", targets);
            targets
        }
        
        // Campo del usuario (ej: Light Screen, Reflect)
        // IGNORA selected_target
        "users-field" => {
            eprintln!("[DEBUG] resolve_targets: target='users-field' - Ignorando selected_target");
            let mut targets = Vec::new();
            if is_position_alive(FieldPosition::PlayerLeft, battle_state, player_team) {
                targets.push(FieldPosition::PlayerLeft);
            }
            if is_position_alive(FieldPosition::PlayerRight, battle_state, player_team) {
                targets.push(FieldPosition::PlayerRight);
            }
            eprintln!("[DEBUG] resolve_targets: Objetivos 'users-field': {:?}", targets);
            targets
        }
        
        // Campo del oponente (ej: Stealth Rock, Spikes)
        // IGNORA selected_target
        "opponents-field" => {
            eprintln!("[DEBUG] resolve_targets: target='opponents-field' - Ignorando selected_target");
            let mut targets = Vec::new();
            if is_position_alive(FieldPosition::OpponentLeft, battle_state, player_team) {
                targets.push(FieldPosition::OpponentLeft);
            }
            if is_position_alive(FieldPosition::OpponentRight, battle_state, player_team) {
                targets.push(FieldPosition::OpponentRight);
            }
            eprintln!("[DEBUG] resolve_targets: Objetivos 'opponents-field': {:?}", targets);
            targets
        }
        
        // El aliado del usuario (ej: Helping Hand, Follow Me)
        // IGNORA selected_target
        "ally" => {
            eprintln!("[DEBUG] resolve_targets: target='ally' - Ignorando selected_target");
            if let Some(ally_pos) = get_ally_position(user_pos) {
                if is_position_alive(ally_pos, battle_state, player_team) {
                    eprintln!("[DEBUG] resolve_targets: Aliado encontrado: {:?}", ally_pos);
                    vec![ally_pos]
                } else {
                    eprintln!("[DEBUG] resolve_targets: Aliado no está vivo");
                    vec![]
                }
            } else {
                eprintln!("[DEBUG] resolve_targets: No hay aliado disponible (formato Single)");
                vec![]
            }
        }
        
        // Objetivo seleccionado específicamente (ej: Tackle, Thunderbolt)
        // AQUÍ SÍ usa selected_target, pero con validación robusta
        "selected-pokemon" => {
            if let Some(target) = selected_target {
                eprintln!("[DEBUG] resolve_targets: target='selected-pokemon' - Usando selected_target: {:?}", target);
                // Validar que el objetivo esté vivo
                if is_position_alive(target, battle_state, player_team) {
                    // Aplicar redirección si está activa
                    let final_target = if let Some(redirected) = apply_redirection(
                        target,
                        user_pos,
                        attacker,
                        move_data,
                        battle_state,
                    ) {
                        eprintln!("[DEBUG] resolve_targets: ¡Redirección aplicada! {:?} -> {:?}", target, redirected);
                        redirected
                    } else {
                        target
                    };
                    vec![final_target]
                } else {
                    eprintln!("[DEBUG] resolve_targets: WARNING - selected_target {:?} no está vivo, retornando vacío", target);
                    vec![]
                }
            } else {
                // Si no hay objetivo seleccionado, usar lógica por defecto según el formato
                use crate::models::BattleFormat;
                match battle_state.format {
                    BattleFormat::Single => {
                        // En Single, si el usuario es del jugador, el objetivo es OpponentLeft
                        // Si el usuario es del oponente, el objetivo es PlayerLeft
                        let default_target = if user_pos == FieldPosition::PlayerLeft || user_pos == FieldPosition::PlayerRight {
                            FieldPosition::OpponentLeft
                        } else {
                            FieldPosition::PlayerLeft
                        };
                        eprintln!("[DEBUG] resolve_targets: selected-pokemon sin target explícito en Single, usando default: {:?}", default_target);
                        // Validar que el objetivo por defecto esté vivo
                        if is_position_alive(default_target, battle_state, player_team) {
                            vec![default_target]
                        } else {
                            eprintln!("[DEBUG] resolve_targets: WARNING - default_target {:?} no está vivo, retornando vacío", default_target);
                            vec![]
                        }
                    }
                    BattleFormat::Double => {
                        // En Double, se requiere un objetivo explícito
                        eprintln!("[DEBUG] resolve_targets: ERROR - selected-pokemon requiere target explícito en Double, retornando vacío");
                        vec![]
                    }
                }
            }
        }
        
        // Por defecto, si no se reconoce el tipo, intentar usar selected_target o retornar vacío
        _ => {
            eprintln!("[DEBUG] resolve_targets: WARNING - Tipo de target desconocido: '{}', intentando usar selected_target", move_target_type);
            if let Some(target) = selected_target {
                if is_position_alive(target, battle_state, player_team) {
                    vec![target]
                } else {
                    eprintln!("[DEBUG] resolve_targets: WARNING - selected_target {:?} no está vivo", target);
                    vec![]
                }
            } else {
                eprintln!("[DEBUG] resolve_targets: ERROR - Tipo desconocido y sin selected_target, retornando vacío");
                vec![]
            }
        }
    }
}

/// Obtiene la posición del aliado del usuario
/// En combates dobles, cada posición tiene un aliado
fn get_ally_position(user_pos: FieldPosition) -> Option<FieldPosition> {
    match user_pos {
        FieldPosition::PlayerLeft => Some(FieldPosition::PlayerRight),
        FieldPosition::PlayerRight => Some(FieldPosition::PlayerLeft),
        FieldPosition::OpponentLeft => Some(FieldPosition::OpponentRight),
        FieldPosition::OpponentRight => Some(FieldPosition::OpponentLeft),
    }
}

/// Verifica si un Pokémon en una posición específica está vivo
/// Retorna true si la posición está ocupada por un Pokémon con HP > 0
fn is_position_alive(
    position: FieldPosition,
    battle_state: &BattleState,
    player_team: &PlayerTeam,
) -> bool {
    use crate::models::BattleFormat;
    match position {
        FieldPosition::PlayerLeft => {
            // En formato Single, solo hay un Pokémon activo
            if battle_state.format == BattleFormat::Single {
                if let Some(&index) = battle_state.player_active_indices.first() {
                    index < player_team.active_members.len() 
                        && player_team.active_members[index].current_hp > 0
                } else {
                    false
                }
            } else {
                // En formato Double, PlayerLeft es el primer índice
                if let Some(&index) = battle_state.player_active_indices.first() {
                    index < player_team.active_members.len() 
                        && player_team.active_members[index].current_hp > 0
                } else {
                    false
                }
            }
        }
        FieldPosition::PlayerRight => {
            // En formato Single, no hay segunda posición
            if battle_state.format == BattleFormat::Single {
                false
            } else {
                // En formato Double, PlayerRight es el segundo índice
                if let Some(&index) = battle_state.player_active_indices.get(1) {
                    index < player_team.active_members.len() 
                        && player_team.active_members[index].current_hp > 0
                } else {
                    false
                }
            }
        }
        FieldPosition::OpponentLeft => {
            if battle_state.is_trainer_battle {
                // En formato Single, solo hay un oponente activo
                if battle_state.format == BattleFormat::Single {
                    if let Some(&index) = battle_state.opponent_active_indices.first() {
                        index < battle_state.opponent_team.len() 
                            && battle_state.opponent_team[index].current_hp > 0
                    } else {
                        false
                    }
                } else {
                    // En formato Double, OpponentLeft es el primer índice
                    if let Some(&index) = battle_state.opponent_active_indices.first() {
                        index < battle_state.opponent_team.len() 
                            && battle_state.opponent_team[index].current_hp > 0
                    } else {
                        false
                    }
                }
            } else {
                // Batalla salvaje - solo hay un oponente
                battle_state.opponent_instance.current_hp > 0
            }
        }
        FieldPosition::OpponentRight => {
            // En formato Single, no hay segunda posición
            if battle_state.format == BattleFormat::Single {
                false
            } else if battle_state.is_trainer_battle {
                // En formato Double, OpponentRight es el segundo índice
                if let Some(&index) = battle_state.opponent_active_indices.get(1) {
                    index < battle_state.opponent_team.len() 
                        && battle_state.opponent_team[index].current_hp > 0
                } else {
                    false
                }
            } else {
                // Batalla salvaje - no hay segunda posición
                false
            }
        }
    }
}

